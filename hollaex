 #!/bin/bash 

#### hollaex-cli Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE=all

GENERATE_PASSWORDS=

DOCKER_COMPOSE_NAME_PREFIX=local

ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS=2

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ dev ] [ local ] [ init ] [ upgrade ] [ terminate ] [ version ]
Options:
    dev (Only for bitHolla developers) :
        --path, Path of hollaex-server codebase
        --app, Name of app to test on
        --command,  Docker-compose commands
        --database_init, Run sequelize db:migrate, db:seed and db triggers after init steps
        --test, Run mocha code test for debugging
        --no_verify, Run script without verifying docker-compose setup
    local :
        --config, Path of hollaex-cli Config file or directory
        --command,  Docker-compose commands
        --deployment_mode, Specify exact container to run on this machine, Such as api
        --without_backends, Running containers only without creating backend components, such as Redis
        --database_init, Run sequelize db:migrate, db:seed and db triggers after init steps
        --no_verify, Run script without verifying docker-compose setup
    init :
        --config, Path of hollaex-cli Config file or directory
        --database_init, Run sequelize db:migrate, db:seed and db triggers after init steps
        --skip_generate_passwords, Skip generated random value passwords
        --no_verify, Run script without verifying connected kubernetes cluster
    upgrade :
        --config, Path of hollaex-cli Config file or directory
        --database_init, Run sequelize db:migrate, db:seed and db triggers after init steps
        --generate_passwords, Generate new random value passwords for replacing existing ones.
        --no_verify, Run script without verifying connected kubernetes cluster
    terminate :
        --config, Path of hollaex-cli Config file or directory
        --no_verify, Run script without verifying connected kubernetes cluster
    version :
        Print out current installed version of hollaex-cli.

EOF
}

if [ "$1" == "dev" ]; then

    while true; do
        [ $# -eq 0 ] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CODEBASE_PATH=$1
                echo "Hollaex-server codebase : $HOLLAEX_CODEBASE_PATH."
                shift; continue
                ;;
            --app)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_APPNAME=$1
                echo "Your target application is : $LOCAL_APPNAME."
                shift; continue
                ;;
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo "Local database initialization enabled."
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo "Local mocha code test mode enabled."
                shift; continue
                ;;
            --no_verify)
                RUN_WITH_VERIFY=false
                echo "Running it wihtout verify the config."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    DOCKER_COMPOSE_NAME_PREFIX=hollaex-server   
    ENVIRONMENT_EXCHANGE_NAME=$LOCAL_APPNAME

    source $SCRIPTPATH/config_form.sh

    # Checking docker-compose is installed on this machine.
    if command docker-compose version > /dev/null 2>&1; then

         echo "*** docker-compose detected ***"
         echo "version: $(docker-compose version)"

    else

         echo "*** hollaex-cli failed to detect docker-compose installed on this machine. Please install it before running hollaex-cli. ***"
         exit 1;

    fi

    # Running database jobs for local db.
    if [ "$LOCAL_DATABASE_INIT" == true ] && [ ! "$LOCAL_COMMAND" ]; then

        if [ "$RUN_WITH_VERIFY" == true ]; then

            echo "*** Are you sure you want to run database init jobs for your local $LOCAL_APPNAME db? (y/n) ***"

            read answer

            if [ "$answer" = "${answer#[Yy]}" ]; then
                echo "*** Exiting... ***"
                exit 0;
            fi

        fi

        local_database_init;

    fi

    # Running local code test
    if [ "$LOCAL_CODE_TEST" == true ] && [ ! "$LOCAL_COMMAND" ]; then

         if  [ ! "$LOCAL_APPNAME" ]; then
            echo "You must specify app name before running local code test."
            exit 1;
        fi

        if [ "$RUN_WITH_VERIFY" == true ]; then

            echo "*** Are you sure you want to run local code test for $LOCAL_APPNAME? (y/n) ***"

            read answer

            if [ "$answer" = "${answer#[Yy]}" ]; then
                echo "*** Exiting... ***"
                exit 0;
            fi

        fi

        local_code_test;

    fi

    #Quit if necessary flags are missing
    if [ ! "$LOCAL_APPNAME" ] || [ ! "$LOCAL_COMMAND" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    if [ "$RUN_WITH_VERIFY" == true ]; then

        echo "*** Are you sure you want to run docker-compose $LOCAL_COMMAND for local $LOCAL_APPNAME development? (y/n) ***"

        read answer

        if [ "$answer" = "${answer#[Yy]}" ] ;then
            echo "*** Exiting... ***"
            exit 0;
        fi

    fi

    #Set current path for hollaex dev command in case of user didn't pass it themselves.
    if [ ! "$HOLLAEX_CODEBASE_PATH" ]; then

        HOLLAEX_CODEBASE_PATH=$(pwd)
        
    fi

    docker-compose -f $HOLLAEX_CODEBASE_PATH/.docker-compose-$LOCAL_APPNAME.yaml $LOCAL_COMMAND

    exit 0;


elif [ "$1" == "local" ]; then

    while true; do
        [ $# -eq 0 ] && break
        case $1 in
            --config)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [ -d "$1" ] ; then
                    CONFIG_FILE_PATH=$1/*
                elif [ -f "$1" ]; then
                    CONFIG_FILE_PATH=$1
                fi 
                echo "Your configuration file : $CONFIG_FILE_PATH."
                shift; continue
                ;;
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --deployment_mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --without_backends)
                LOCAL_WITHOUT_BACKENDS=true
                echo "Skip creating backend components. Rnning $LOCAL_DEPLOYMENT_MODE only on this machine."
                shift; continue
                ;;
            --generate_passwords)
                GENERATE_PASSWORDS=true
                echo "Enable generating random password values. Make sure that you already removed existing values on config file."
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo "Local database initialization enabled."
                shift; continue
                ;;
            --no_verify)
                RUN_WITH_VERIFY=false
                echo "Running it wihtout verify the config."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    #Quit if necessary flags are missing
    if [ ! "$CONFIG_FILE_PATH" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/config_form.sh
    load_config_variables;

    # Checking docker-compose is installed on this machine.
    if command docker-compose version > /dev/null 2>&1; then

         echo "*** docker-compose detected ***"
         echo "version: $(docker-compose version)"

    else

         echo "*** hollaex-cli failed to detect docker-compose installed on this machine. Please install it before running hollaex-cli. ***"
         exit 1;

    fi

    if [ ! -d "$SCRIPTPATH/local" ]; then
        mkdir $SCRIPTPATH/local;
    fi

    if [ ! -d "$SCRIPTPATH/local/nginx" ]; then
        mkdir $SCRIPTPATH/local/nginx;
    fi

    if [ ! -d "$SCRIPTPATH/local/nginx/conf.d" ]; then
        mkdir $SCRIPTPATH/local/nginx/conf.d;
    fi

    #if [ ! -f "$SCRIPTPATH/local/logs/nginx/error.log" ]; then
    #    touch $SCRIPTPATH/local/logs/nginx/error.log;
    #fi

    # Running database jobs for local db.
    if [ "$LOCAL_DATABASE_INIT" == true ] && [ ! "$LOCAL_COMMAND" ]; then

        if [ "$RUN_WITH_VERIFY" == true ]; then

            echo "*** Are you sure you want to run database init jobs for your local $ENVIRONMENT_EXCHANGE_NAME db? (y/n) ***"

            read answer

            if [ "$answer" = "${answer#[Yy]}" ]; then
                echo "*** Exiting... ***"
                exit 0;
            fi

        fi

        local_database_init;

    fi

    #Quit if necessary flags are missing
    if [ ! "$LOCAL_COMMAND" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    if [ "$RUN_WITH_VERIFY" == true ]; then

        echo "*** Are you sure you want to run docker-compose $LOCAL_COMMAND for $ENVIRONMENT_EXCHANGE_NAME on your local? (y/n) ***"

        read answer

        if [ "$answer" = "${answer#[Yy]}" ] ;then
            echo "*** Exiting... ***"
            exit 0;
        fi

    fi

    if [ "$GENERATE_PASSWORDS" == true ]; then

        #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;
        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;
        load_config_variables;

    fi

    if [ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]; then

        generate_local_env;

    fi

    if [ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]; then

        generate_local_docker_compose $LOCAL_DEPLOYMENT_MODE;

    fi

    generate_nginx_conf $LOCAL_DEPLOYMENT_MODE;

    if [ ! "$LOCAL_COMMAND" == "down" ]; then

        docker-compose -f $SCRIPTPATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml $LOCAL_COMMAND

    else

        docker-compose -f $SCRIPTPATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml $LOCAL_COMMAND --remove-orphans
    
    fi

    exit 0;

elif [ "$1" == "init" ]; then

    while true; do
        [ $# -eq 0 ] && break
        case $1 in
           --config)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [ -d "$1" ] ; then
                    CONFIG_FILE_PATH=$1/*
                elif [ -f "$1" ]; then
                    CONFIG_FILE_PATH=$1
                fi
                echo "Your configuration file : $CONFIG_FILE_PATH."
                shift; continue
                ;;
           --skip_generate_passwords)
                GENERATE_PASSWORDS=false
                echo "Skipping generating random passwords. Make sure that you already defined those values on config file."
                shift; continue
                ;;
            --no_verify)
                RUN_WITH_VERIFY=false
                echo "Running it wihtout verify the config."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    #Quit if necessary flags are missing
    if [ ! "$CONFIG_FILE_PATH" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/config_form.sh
    load_config_variables;

    #Checking Kubernetes dependencies
    check_kubernetes_dependencies;

    #Creating kubernetes_config directory for generating config for Kubernetes.
    if [ ! -d "$SCRIPTPATH/kubernetes/config" ]; then
        mkdir $SCRIPTPATH/kubernetes/config;
    fi

    if [ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ] || [ ! "$ENVIRONMENT_EXCHANGE_NAME"  ] ; then
        echo "Error : Please define exchange name and Docker image version on config file before running hollaex-cli."
        print_usage
        exit 1;
    fi
    

    echo "*** Verifying current KUBECONFIG on the machine ***"
    kubectl get nodes

    if [ "$RUN_WITH_VERIFY" == true ]; then

        if [ "$DATABASE_INIT" == true ]; then

            echo "*** Are you sure you want to initialize $ENVIRONMENT_EXCHANGE_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($KUBERNETES_CONFIGMAP_API_HOST) with automatic database initalization on this cluster? (y/n) ***"

        else 

            echo "*** Are you sure you want to initialize $ENVIRONMENT_EXCHANGE_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($KUBERNETES_CONFIGMAP_API_HOST) on this cluster? (y/n) ***"

        fi

        read answer

        if [ "$answer" = "${answer#[Yy]}" ] ;then
            echo "*** Exiting... ***"
            exit 0;
        fi

    fi

    if [ "$GENERATE_PASSWORDS" == true ]; then

        #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;
        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;
        load_config_variables;

    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]; then

        echo "Generating Kubernetes Configmap"
        generate_kubernetes_configmap;

    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]; then

        echo "Generating Kubernetes Secret"
        generate_kubernetes_secret;

    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]; then

        echo "Generating Kubernetes Ingress"
        generate_kubernetes_ingress;

    fi

    echo "*** Creating namespace on Kubernetes ***"
    kubectl create ns $ENVIRONMENT_EXCHANGE_NAME

    echo "*** Applying configmap on the namespace ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

    echo "*** Applying secret on the namespace ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

    if [ "$ENVIRONMENT_KUBERNETES_USE_EXTERNAL_REDIS" == false ]; then

        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

        echo "*** Running Redis ***"
        
        if [ "$ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS" == true ]; then

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis  --namespace $ENVIRONMENT_EXCHANGE_NAME --set NodePort.enable="true" --set NodePort.port="$ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT" $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis
       
        else

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis  --namespace $ENVIRONMENT_EXCHANGE_NAME $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis
        fi

    fi

    if [ "$ENVIRONMENT_KUBERNETES_USE_EXTERNAL_POSTGRESQL" == false ]; then

        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_NODESELECTOR postgresql
        echo "*** Running PostgreSQL DB ***"

        if [ "$ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_ACCESS" == true ]; then

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set NodePort.enable="true" --set NodePort.port="$ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_ACCESS_PORT" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $SCRIPTPATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres

        else

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $SCRIPTPATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres

        fi

    fi

    if [ "$ENVIRONMENT_KUBERNETES_USE_EXTERNAL_INFLUXDB" == false ]; then

        if [ "$ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR" ]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

        fi

        echo "*** Running InfluxDB ***"
        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb --namespace $ENVIRONMENT_EXCHANGE_NAME --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret"  -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml -f $SCRIPTPATH/kubernetes/config/nodeSelector-influxdb.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb

    fi

    echo "*** Applying ingress on the namespace ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

    if [ ! "$ENVIRONMENT_KUBERNETES_DOCKER_HUB_USERNAME" ] || [ ! "$ENVIRONMENT_KUBERNETES_DOCKER_HUB_PASSWORD" ] || [ ! "$ENVIRONMENT_KUBERNETES_DOCKER_HUB_EMAIL" ]; then

        echo "*** One of your docker registry credentials are missing! ***"

        echo "Docker registry username :"
        read username
            
        ENVIRONMENT_KUBERNETES_DOCKER_HUB_USERNAME=$username


        echo "Docker registry password :"
        read password

        ENVIRONMENT_KUBERNETES_DOCKER_HUB_PASSWORD=$password

        echo "Docker registry email :"
        read email

        ENVIRONMENT_KUBERNETES_DOCKER_HUB_EMAIL=$email

        echo "*** Your docker registry credentials ***"
        echo "USERNAME - $ENVIRONMENT_KUBERNETES_DOCKER_HUB_USERNAME"
        echo "PASSWORD - $ENVIRONMENT_KUBERNETES_DOCKER_HUB_PASSWORD" 
        echo "EMAIL - $ENVIRONMENT_KUBERNETES_DOCKER_HUB_EMAIL"
        echo "** Are you sure you want to proceed with this credentials? (y/n) ***"

        read answer

            if [ "$answer" = "${answer#[Yy]}" ] ;then
                echo "*** Exiting... ***"
                exit 0;
            fi

    fi

    echo "*** Creating Docker registry secret on $ENVIRONMENT_EXCHANGE_NAME namespace ***"
    kubectl create secret docker-registry bitholla-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME --docker-server=docker.io --docker-username=$ENVIRONMENT_KUBERNETES_DOCKER_HUB_USERNAME --docker-password=$ENVIRONMENT_KUBERNETES_DOCKER_HUB_PASSWORD --docker-email=$ENVIRONMENT_KUBERNETES_DOCKER_HUB_EMAIL

    # FOR GENERATING NODESELECTOR VALUES
    generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR hollaex

    echo "*** Running HollaEx server containers ***"

    helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="api" --set dockerTag="$ENVIRONMENT_DOCKER_IMAGE_VERSION" --set stable.replicaCount="$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS" --set autoScaling.hpa.enable="false" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

    helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-ws --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="ws" --set dockerTag="$ENVIRONMENT_DOCKER_IMAGE_VERSION" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

    helm_dynamic_trading_paris run;

    sleep 5;

    echo "Waiting for 60 seconds to Pods get ready to run database jobs..."
    sleep 60;

    echo "*** Running sequelize db:migrate ***"
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- sequelize db:migrate 

    echo "*** Running Database Triggers ***"
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/runTriggers.js

     echo "*** Running sequelize db:seed:all ***"
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- sequelize db:seed:all 

    echo "*** Running InfluxDB migrations ***"
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/createInflux.jobs
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/migrateInflux.js
    kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/initializeInflux.js

    
    echo "*** All done! ***"
    echo "*** Your $ENVIRONMENT_EXCHANGE_NAME ($KUBERNETES_CONFIGMAP_API_HOST) will be available in few minutes. If there's an issue, please review logs and try it again. ***"

    exit 0;

elif [ "$1" == "upgrade" ]; then

    while true; do
        [ $# -eq 0 ] && break
        case $1 in
            --config)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [ -d "$1" ] ; then
                    CONFIG_FILE_PATH=$1/*
                elif [ -f "$1" ]; then
                    CONFIG_FILE_PATH=$1
                fi
                echo "Your configuration file : $CONFIG_FILE_PATH."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKEND_COMPONENTS=true
                echo "Backend components upgrade enabled."
                shift; continue
                ;;
            --generate_passwords)
                GENERATE_PASSWORDS=true
                echo "Enable generating random password values. Make sure that you already removed existing values on config file."
                shift; continue
                ;;
            --database_init)
                DATABASE_INIT=true
                echo "Database initialization enabled."
                shift; continue
                ;;
            --no_verify)
                RUN_WITH_VERIFY=false
                echo "Running it wihtout verify the config."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    #Quit if necessary flags are missing
    if [ ! "$CONFIG_FILE_PATH" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    source $SCRIPTPATH/config_form.sh
    load_config_variables;

    #Checking Kubernetes dependencies
    check_kubernetes_dependencies;

    #Creating kubernetes_config directory for generating config for Kubernetes.
    if [ ! -d "$SCRIPTPATH/kubernetes/config" ]; then
        mkdir $SCRIPTPATH/kubernetes/config;
    fi

    if [ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ] || [ ! "$ENVIRONMENT_EXCHANGE_NAME"  ] ; then
        echo "Error : Please define exchange name and Docker image version on config file before running hollaex-cli."
        print_usage
        exit 1;
    fi

    echo "*** Verifying current KUBECONFIG on the machine ***"
    kubectl get nodes

    if [ "$RUN_WITH_VERIFY" == true ]; then

        if [ "$STAGING_VERSION" ] && [ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION" ]; then

            echo "*** Are you sure you want to enable / upgrade $ENVIRONMENT_EXCHANGE_NAME-server-api staging v$STAGING_VERSION with $STAGING_REPLICACOUNT containers on this cluster? (y/n) ***"

        elif [ "$STAGING_VERSION" ] && [ "$ENVIRONMENT_DOCKER_IMAGE_VERSION" ]; then

            echo "*** Are you sure you want to upgrade $ENVIRONMENT_EXCHANGE_NAME to v$ENVIRONMENT_DOCKER_IMAGE_VERSION with $ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS api containers, and enable / upgrade $ENVIRONMENT_EXCHANGE_NAME-server-api staging to v$STAGING_VERSION with $STAGING_REPLICACOUNT containers on this cluster? (y/n) ***"

        else
            
            echo "*** Are you sure you want to upgrade $ENVIRONMENT_EXCHANGE_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION with $ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS api containers on this cluster? (y/n) ***"

        fi

        read answer

        if [ "$answer" = "${answer#[Yy]}" ] ;then
            echo "*** Exiting... ***"
            exit 0;
        fi

    fi

    if [ "$GENERATE_PASSWORDS" == true ]; then

        #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;
        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;
        load_config_variables;
        
    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]; then

        echo "Generating Kubernetes Configmap"
        generate_kubernetes_configmap;

    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]; then

        echo "Generating Kubernetes Configmap"
        generate_kubernetes_secret;

    fi

    if [ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]; then

        echo "Generating Kubernetes Configmap"
        generate_kubernetes_ingress;

    fi

    echo "*** Removing $ENVIRONMENT_EXCHANGE_NAME ingress rule on the cluster. ***"
    kubectl delete -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

    echo "*** Applying latest configmap env on the cluster. ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

    echo "*** Applying latest secret on the cluster ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml


    if [ "$UPGRADE_BACKEND_COMPONENTS" == true ]; then

        echo "*** Upgrading Redis ***"
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

        if [ "$ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS" == true ]; then

            helm upgrade --install --recreate-pods $ENVIRONMENT_EXCHANGE_NAME-redis  --namespace $ENVIRONMENT_EXCHANGE_NAME --set NodePort.enable="true" --set NodePort.port="$ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT"  $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis
       
        else

            helm upgrade --install --recreate-pods $ENVIRONMENT_EXCHANGE_NAME-redis  --namespace $ENVIRONMENT_EXCHANGE_NAME  $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis
        fi

        echo "*** Running PostgreSQL DB ***"
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_NODESELECTOR postgresql

        if [ "$ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_ACCESS" == true ]; then

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set NodePort.enable="true" --set NodePort.port="$ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_ACCESS_PORT" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $SCRIPTPATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres

        else

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $SCRIPTPATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres

        fi

        echo "*** Upgrading InfluxDB ***"
        helm upgrade --install --recreate-pods $ENVIRONMENT_EXCHANGE_NAME-influxdb --namespace $ENVIRONMENT_EXCHANGE_NAME --set persistence.size=$ENVIRONMENT_KUBERNETES_INFLUXDB_VOLUMESIZE --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret"  $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb
    
    fi

    # FOR GENERATING NODESELECTOR VALUES
    generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

    echo "*** Upgrading $ENVIRONMENT_EXCHANGE_NAME Pods on Kubernetes. ***"
    helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="api" --set dockerTag="$ENVIRONMENT_DOCKER_IMAGE_VERSION" --set stable.replicaCount="$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS" --set autoScaling.hpa.enable="false" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $SCRIPTPATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

    helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-ws --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="ws" --set dockerTag="$ENVIRONMENT_DOCKER_IMAGE_VERSION" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $SCRIPTPATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

    helm_dynamic_trading_paris run;

    if [ "$DATABASE_INIT" == true ]; then

        echo "Waiting for 60 seconds to Pods get ready to run database jobs..."
        sleep 60;

        echo "*** Running sequelize db:migrate ***"
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- sequelize db:migrate 

        echo "*** Running Database Triggers ***"
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/runTriggers.js

        echo "*** Running InfluxDB migrations ***"
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/initializeInflux.js
        
    fi

    echo "*** Applying $ENVIRONMENT_EXCHANGE_NAME ingress rule on the cluster. ***"
    kubectl apply -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

    sleep 5;

    echo "*** All done! ***"
    echo "*** Your $ENVIRONMENT_EXCHANGE_NAME ($KUBERNETES_CONFIGMAP_API_HOST) will be available in few minutes. If there's an issue, please review logs and try it again. ***"

    exit 0;


elif [ "$1" == "terminate" ]; then

    while true; do
        [ $# -eq 0 ] && break
        case $1 in
            --config)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [ -d "$1" ] ; then
                    CONFIG_FILE_PATH=$1/*
                elif [ -f "$1" ]; then
                    CONFIG_FILE_PATH=$1
                fi
                echo "Your configuration file : $CONFIG_FILE_PATH."
                shift; continue
                ;;
            --no_verify)
                RUN_WITH_VERIFY=false
                echo "Running it wihtout verify the config."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    #Quit if necessary flags are missing
    if [ ! "$CONFIG_FILE_PATH" ]; then

        echo "*** Some necessary flags are missing! Please check agian your command. ***"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/config_form.sh
    load_config_variables;

    #Checking Kubernetes dependencies
    check_kubernetes_dependencies;

    echo "*** Verifying current KUBECONFIG on the machine ***"
    kubectl get nodes

    if [ "$RUN_WITH_VERIFY" == true ]; then

        echo "*** Are you sure you want to terminate $ENVIRONMENT_EXCHANGE_NAME on this cluster? (y/n) ***"

        read answer

        if [ "$answer" = "${answer#[Yy]}" ] ;then
            echo "*** Exiting... ***"
            exit 0;
        fi

    fi

    echo "*** Removing $ENVIRONMENT_EXCHANGE_NAME ingress rule on the cluster. ***"
    kubectl delete -f $SCRIPTPATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

    echo "*** Removing helm packages on the cluster. ***"
    helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-api
    helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-ws
    
    helm_dynamic_trading_paris terminate;

    helm del --purge $ENVIRONMENT_EXCHANGE_NAME-redis 
    helm del --purge $ENVIRONMENT_EXCHANGE_NAME-db
    helm del --purge $ENVIRONMENT_EXCHANGE_NAME-influxdb

    echo "*** Removing $ENVIRONMENT_EXCHANGE_NAME namespace. ***"
    kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

    echo "*** All done! ***"
    echo "*** $ENVIRONMENT_EXCHANGE_NAME ($KUBERNETES_CONFIGMAP_API_HOST) has been successfully removed. If there's an issue, please review logs and try it again. ***"

    exit 0;

elif [ "$1" == "version" ]; then

    echo "hollaex-cli : v$(cat $SCRIPTPATH/version)"

else

    print_usage;

    exit 0;

fi
