#!/bin/bash 

SCRIPTPATH="$HOME/.hollaex-cli"

#### HollaEx CLI Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE='all'

GENERATE_PASSWORDS=false

DOCKER_COMPOSE_NAME_PREFIX='local'

ENVIRONMENT_BRIDGE_TARGET_SERVER='api.bitholla.com'

source $SCRIPTPATH/version_range

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ init ] [ setup ] [ start ] [ restart ] [ stop ] [ build ] [ upgrade ] [ terminate ] [ web ] [ toolbox ] [ status ] [ logs ] [ version ] (--flags)

General Flags (Except for 'hollaex init', 'hollaex import'):
    --path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.
    --skip, Run command without user's double confirmation.

Options:
    init: Pull HollaEx Kit for your new exchange.

    setup: Setup the exchange for the first launch.
        --reconfigure, Reconfigure basic settings such as Server domain or Activation Code.
    
    import: Import settings files generated by using bitHolla Dashboard (dash.bitholla.com).
        --file, Path of file or directory where settings files are stored.
    
    login: Log in with bitHolla Dashboard account and select my Activation code. 

    logout: Log out and remove my bound Activation code on local.

    pull: Pull my Exchange configurations from bitHolla Dashboard to local.

    start: Start the exchange which already been configured by 'hollaex setup' command.

    prod: Bring up the exchange as production. Including public domain setup and SSL configuraiton.

    restart: Restart the existing exchange.
    
    stop: Stop the exchagne which already been running.

    build: Build the Docker image for running HollaEx Kit, includes user custom configurations.
    
    upgrade: Upgrade the exchange to new version.
        --version, Version number of HollaEx Core to upgrade.
        --user-image-registry, Specify Docker registry and version (tag) for the user HollaEx Core image.

    terminate: Terminate the existing exchange. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE.
      
    web: Run web server for the exchange.
        --setup, Setup the web server for the first launch.
        --start, Start the web server 
        --stop, Stop the web server.
        --restart, Restart the web server while applying new changes (If it's available).
        --build, Build the web server docker image. This command would not affect the existing web server before restart.
        --terminate, Terminate the web server. THIS COMMAND WILL COMPLETELY REMOVE YOUR WEB CLIENT.

    toolbox: Toolbox for advanced features which could be helpful for your exchange operations.
        --backup, Run the full backup with 'pg_dumpall' for exchange's PostgreSQL database.
        --flush_redis, Run the full flush of Redis stored data.
        --upgrade_api_only, Do zero-downtime rolling upgrade for exchange API contianers on Kubernetes.
        --add_coin, Add new currency on exchange.
        --remove_coin, Remove exisiting currency from exhcnage.
        --add_trading_pair, Add new trading pair on ehchange.
        --remove_trading_pair, Remove existing trading pair from exchange.
        --issue_ssl, Issue SSL certificate on local Nginx by using Let's Encrypt.
        --renew_ssl, Renew SSL certificate on local Nginx by using Let's Encrypt.
        --update_registry_secret, Update existing docker registry secret for Kubernetes.
        --set_config, Update constants configured on the exchange database.
        --set_activation_code, Set or update activation code for the exchange.
        --connect_database, Direct connection to PostgreSQL Database via postgresql-client.
        --connect_redis, Direct connection to Redis via redis-client.
        --connect_influxdb, Direct connection to InfluxDB via influx-client.
        
    status: Show the exchange server status.

    logs: Show overview of logs from the exchange server. 

    version: Print out current installed version of HollaEx CLI.

EOF
}

function dev_print_usage() {
/bin/cat << EOF

# All 'hollaex dev' commands should be run at HollaEx Core directory.

Usage : 
    hollaex [ dev ] (--flags)

General Flags :
    --kit-path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --skip, Run command without user's double confirmation.

Options:
    --command: Run Docker-Compose commands. (up, down, stop, --build)

    --database_init: Run database initialization scripts.

    --add_coin: Add coin(s) on dev HollaEx environment.
    
    --remove_coin: Remove coin(s) on dev HollaEx environment.
    
    --add_trading_pair: Add trading pair(s) on dev HollaEx environment.

    --remove_trading_pair: Remove trading pair(s) on dev HollaEx environment.

EOF
}

if [[ "$1" == "dev" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --codebase)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CODEBASE_PATH=$1
                echo "HollaEx Core Codebase Path : $HOLLAEX_CODEBASE_PATH."
                shift; continue
                ;;
            --kit-path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_KIT_PATH=$1
                echo "HollaEx Kit Path : $HOLLAEX_KIT_PATH."
                shift; continue
                ;;
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --setup)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND="up --build"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --start)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND="start"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --stop)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND="stop"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --restart)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND="restart"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --terminate)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND="down"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo 'Local database initialization enabled.'
                shift; continue
                ;;
            --generate_passwords)
                GENERATE_PASSWORDS=true
                echo "Enable generating random password values. Make sure that you already removed existing values on config file."
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo 'Local mocha code test mode enabled.'
                shift; continue
                ;;
            --add_coin)
                LOCAL_ADD_COIN=true
                echo 'Adding coin for dev environment.'
                shift; continue
                ;;
            --add_trading_pair)
                LOCAL_ADD_PAIR=true
                echo 'Adding trading pair for dev environment.'
                shift; continue
                ;;
            --remove_coin)
                LOCAL_REMOVE_COIN=true
                echo 'Removing coin for dev environment.'
                shift; continue
                ;;
            --remove_trading_pair)
                LOCAL_REMOVE_PAIR=true
                echo 'Removing trading pair for dev environment.'
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                dev_print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    IS_DEVELOP=true

    if [[ ! "$HOLLAEX_KIT_PATH" ]]; then

        echo "Error: HollaEx Kit path has not been defined."
        echo "Please use '--kit-path' flag to specify your Kit path."
        exit 1;

    fi

    CONFIG_FILE_PATH=$HOLLAEX_KIT_PATH/settings/*
    TEMPLATE_GENERATE_PATH=$HOLLAEX_KIT_PATH/templates
    INIT_PATH_CHECK=$HOLLAEX_KIT_PATH/.hollaex

    if [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

        HOLLAEX_CODEBASE_PATH=$(pwd)

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # ADD & REMOVE COINS AND PAIRS INTERATION FOR DEV
    if [[ "$LOCAL_ADD_COIN" ]]; then    

        add_coin_input

        add_coin_exec

        exit 0;

    elif [[ "$LOCAL_REMOVE_COIN" ]]; then

        remove_coin_input

        remove_coin_exec

        exit 0;


    elif [[ "$LOCAL_ADD_PAIR" ]]; then

        add_pair_input

        add_pair_exec

        exit 0;


    elif [[ "$LOCAL_REMOVE_PAIR" ]]; then

        remove_pair_input

        remove_pair_exec

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then
            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else
            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    

        #Quit if necessary flags are missing
        if [[ ! "$LOCAL_COMMAND" ]] && [[ ! "$LOCAL_DATABASE_INIT" ]]; then
            echo "*********************************************"
            echo "Make sure to specify --command flag for dev commands"
            echo "*********************************************"
            print_usage;
            exit 1;

        fi

        # Running database jobs for local db.
        if [[ ! "$LOCAL_COMMAND" ]] && [[ "$LOCAL_DATABASE_INIT" == true ]]; then
        
            local_database_init dev;

            exit 0;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to run $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$GENERATE_PASSWORDS" == true ]]; then

            #Generating random values for passwords and update config file to contain it;
            update_random_values_to_config;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then

            generate_local_docker_compose_for_dev;
        fi

        generate_nginx_upstream;

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-dev-docker-compose.yaml $LOCAL_COMMAND

        # Running database jobs for local db.
        if [[ "$LOCAL_DATABASE_INIT" == true ]]; then

            local_database_init dev;

        fi

        exit 0;

    fi


elif [[ "$1" == "init" ]]; then
    
    # while true; do
    #     [[ $# -eq 0 ]] && break
    #     case $1 in
    #         # --name)
    #         #     shift 
    #         #     case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
    #         #     ENVIRONMENT_EXCHANGE_NAME=$1
    #         #     echo "Name of your Exchange : $ENVIRONMENT_EXCHANGE_NAME."
    #         #     shift; continue
    #         #     ;;
    #         --standalone)
    #             shift 
    #             HOLLAEX_INIT_STANDALONE=true
    #             echo "HollaEx CLI will proceed to generate initialized directory without pulling HollaEx Kit repo."
    #             shift; continue
    #             ;;
    #     esac
    #     shift
    # done

    # #Quit if name of exchange is missing
    # if [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]]; then

    #     echo "You must specify the name of your Exchange! Use `--name` flag to pass name."
    #     print_usage;
    #     exit 1;

    # fi

    # if [[ ! "$HOLLAEX_INIT_STANDALONE" ]]; then

        echo "Pulling remote HollaEx Kit repo on $(pwd)"
        if command git clone https://github.com/bitholla/hollaex-kit.git; then
            
            HOLLAEX_CLI_INIT_PATH=$(pwd)/hollaex-kit
            CONFIG_FILE_PATH=$(pwd)/hollaex-kit/settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/hollaex-kit/templates
            INIT_PATH_CHECK=$(pwd)/hollaex-kit/.hollaex

            echo "HollaEx Kit is successfully initialized."
            echo "You can go to: $(pwd)/hollaex-kit and start setting up your exchange with 'hollaex setup' command."
            

        else 

            printf "\033[91mFailed to pull HollaEx Kit repository from GitHub. Please check your internet connectivity.\033[39m\n"
            exit 1;

        fi

    # else 

    #     HOLLAEX_CLI_INIT_PATH=$(pwd)/$ENVIRONMENT_EXCHANGE_NAME

    #     if [[ -d "$HOLLAEX_CLI_INIT_PATH" ]]; then

    #         echo "Init path exists! HollaEx CLI can't override exsiting exchange files."
    #         exit 1;
    #     fi

    #     echo "Initializing new Exchange - $HOLLAEX_CONFIGMAP_API_NAME on $HOLLAEX_CLI_INIT_PATH ..."

    #     mkdir $HOLLAEX_CLI_INIT_PATH

    #     cp -r $SCRIPTPATH/settings $HOLLAEX_CLI_INIT_PATH/settings
    #     cp -r $SCRIPTPATH/plugins $HOLLAEX_CLI_INIT_PATH/plugins
    #     cp -r $SCRIPTPATH/templates $HOLLAEX_CLI_INIT_PATH/templates
    #     touch $HOLLAEX_CLI_INIT_PATH/.hollaex
    #     echo "Initialized by using HollaEx CLI v$(cat $SCRIPTPATH/version)" >> $HOLLAEX_CLI_INIT_PATH/.hollaex

    #     # grep -v ENVIRONMENT_EXCHANGE_NAME= $HOLLAEX_CLI_INIT_PATH/settings/configmap > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     # (echo "ENVIRONMENT_EXCHANGE_NAME=$ENVIRONMENT_EXCHANGE_NAME" && cat $HOLLAEX_CLI_INIT_PATH/settings/configmap) > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     echo "All done!"
    #     echo "To run HollaEx CLI commands further, Please get into initialized path first to let HollaEx CLI reads settings."

    # fi
        
        exit 0;
    
elif [[ "$1" == "setup" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --reconfigure)
                RECONFIGURE_BASIC_SETTINGS=true
                echo "HollaEx CLI will proceed to reconfigure your exchange's basic settings."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    # Check Kit version compatibility range.
    check_version_compatibility_range;
    
    # hollaex setup --reconfigure
    if [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to reconfigure the exchange? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Ask for basic necessary settings
        launch_basic_settings_input;

        #hollaex upgrade --skip $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)

        echo "All done!"
        echo "Make sure to check your settings files been successfully updated by following your provided values."
        echo "You can run 'hollaex restart (--kube)' for applying the updated values on your exchange."

        exit 0;

    fi
    
    # PRESET env for user initial setup config value selection
    CONTINUE_WITH_PRECONFIGURED_VALUES=false 

    # Check that settings files are already configured.
    if [[ ! "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] && [[ $HOLLAEX_SECRET_ACTIVATION_CODE ]]; then

        echo "HollaEx CLI detected the preconfigured values on your HollaEx Kit."
        echo "Do you want to proceed with this configurations? (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
            export CONTINUE_WITH_PRECONFIGURED_VALUES=false
        
        else 

            export CONTINUE_WITH_PRECONFIGURED_VALUES=true

            # Exporting settings values
            for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
            done;

            source $SCRIPTPATH/tools_generator.sh
            load_config_variables;

        fi

    fi

    if [[ "$CONTINUE_WITH_PRECONFIGURED_VALUES" == false ]]; then

        printf "\nWelcome to HollaEx Setup!\n\n"

        echo -e "You need to \033[1msetup your exchange\033[0m with the configurations."
        echo -e "You can follow the \033[1mexchange setup wizard\033[0m on \033[1mhttps://dash.bitholla.com\033[0m before you do this process. (Recommended)"
        echo -e "\033[1mHave you already setup your exchange on bitHolla Dashboard? (Y/n)\033[0m"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then

            printf "\nWe recommend you to setup your exchange on \033[1mbitHolla dashboard (dash.bitholla.com)\033[0m before you proceed.\n"
            printf "Select \033[1m'Y'\033[0m to \033[1mquit the CLI\033[0m in order to first setup your exchange on the dashboard,\n" 
            printf "Select \033[1m'N'\033[0m to proceed \033[1mmanual\033[0m CLI exchange setup wizard.\n" 
            echo "Do you want to quit the CLI setup? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
                
                echo "Proceeding to a CLI exchange wizard..."
                launch_basic_settings_input;
            
            else 

                printf "\n\nPlease visit \033[1mdash.bitholla.com\033[0m and setup your exchange there first.\n"
                printf "Once your exchange is configured on the dashboard, please start the procedure by using \033[1m'hollaex setup'\033[0m.\n\n"
                exit 1;
            
            fi
        
        else 

            if ! command hollaex login; then

                exit 1;

            fi

            if ! command hollaex pull --skip; then

                exit 1;

            fi

        fi

        for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
        done;

        source $SCRIPTPATH/tools_generator.sh
        load_config_variables;

    fi

    
    export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$ENVIRONMENT_DOCKER_IMAGE_VERSION

    override_docker_image_version;
    export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
    
    build_user_hollaex_core;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        # launch_basic_settings_input;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your remote Kubernetes environment.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to launch $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress."
            generate_kubernetes_ingress;

        fi
        
        echo "Creating namespace on Kubernetes."
        kubectl create ns $ENVIRONMENT_EXCHANGE_NAME

        echo "Applying configmap on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
        
        echo "Applying secret on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

            echo "Running Redis."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis --namespace $ENVIRONMENT_EXCHANGE_NAME --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)
        
        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql
            echo "Running PostgreSQL DB."

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" == true ]]; then

            if [[ "$ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR" ]]; then

                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

            fi

            echo "Running InfluxDB."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb --namespace $ENVIRONMENT_EXCHANGE_NAME --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set persistence.size="$ENVIRONMENT_KUBERNETES_INFLUXDB_VOLUMESIZE" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)

        fi

        echo "Applying ingress on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml
        
        create_kubernetes_docker_registry_secret;

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Running $HOLLAEX_CONFIGMAP_API_NAME workload containers."

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                     --wait \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --recreate-pods \
                     --set DEPLOYMENT_MODE="api" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set stable.replicaCount="$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS" \
                     --set autoScaling.hpa.enable="true" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --recreate-pods \
                     --set DEPLOYMENT_MODE="stream" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="plugins-controller" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm_dynamic_trading_paris run;

        sleep 5;

        kubernetes_database_init launch;

        hollaex_setup_finalization;

        # hollaex_ascii_exchange_has_been_setup;

        echo "Shutting down the exchange..."
        hollaex stop --kube --skip
        
        echo "Finalizing the exchange setup..."
        sleep 5;

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"  
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if command docker ps -a | grep local_$ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your machine.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            printf "\033[91mIf you want to just update settings values, Please run 'hollaex setup --reconfigure' instead.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
        

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     echo "Are you sure you want to run $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        # #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi
    
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

             # Running database init
            RUN_WITH_VERIFY=false
            local_database_init start;

             # Restarting containers after database init jobs.
            echo "Restarting containers to apply database changes."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

        else 

            printf "\033[91mHollaEx CLI failed to launch containers. Please review your settings and try again.\033[39m\n"
            exit 1;
       
        fi
        
        hollaex_setup_finalization;

        # hollaex_ascii_exchange_has_been_setup;

        # echo "Finalizing the exchange setup..."
        # sleep 5;

        exit 0;

    fi

elif [[ "$1" == "import" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_IMPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_IMPORT_PATH <<< "$HOLLAEX_IMPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi

# Storing current CURRENCIES and PARIS
cat > $HOLLAEX_CLI_INIT_PATH/.old/old-currencies-and-pairs <<EOL

OLD_CURRENCIES=$(echo $HOLLAEX_CONFIGMAP_CURRENCIES)
OLD_PAIRS=$(echo $HOLLAEX_CONFIGMAP_PAIRS)

EOL

    if [[ "${HOLLAEX_IMPORT_PATH[@]}" == *"json"* ]]; then

         # Returns error If 'jq' doesn't exists.
        if ! command jq --version > /dev/null 2>&1; then

            printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
            echo "HollaEx CLI requires 'jq' to handle certain functionalities."
            echo "Please install it first and try again."

            printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
            printf "For macOS users with Homebrew: 'brew install jq'\n\n"

            exit 1;

        fi

        echo "Converting imported file to HollaEx CLI settings file format..."

        for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

        done

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done
        
        BITHOLLA_USER_EXCHANGE_LIST=$(cat $HOLLAEX_IMPORT_PATH)

        # SAVING USER ACTIVATION CODE.
        export EXCHANGE_USER_ACTIVATION_CODE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].activation_code";);
        sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${EXCHANGE_USER_ACTIVATION_CODE}/" $SECRET_FILE_PATH;
        rm $SECRET_FILE_PATH.bak

        BITHOLLA_USER_EXCHANGE_ORDER=0

        hollaex_pull_and_apply_exchange_data;

        apply_coins_config_to_settings_file;

        apply_pairs_config_to_settings_file;

        if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

            IS_IMPORT_SUCCESS=true

        else 

            IS_IMPORT_SUCCESS=false

        fi

    else 

        rm $CONFIG_FILE_PATH

        for i in ${HOLLAEX_IMPORT_PATH[@]}; do

            if [[ -d "$i" ]]; then
                
                if command cp $i/* $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi

            elif [[ -f "$i" ]]; then

                if command cp $i $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi
            
            fi

        done;

        if [[ -d "$HOLLAEX_IMPORT_PATH" ]]; then
            
            if command cp $HOLLAEX_IMPORT_PATH/* $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi

        elif [[ -f "$HOLLAEX_IMPORT_PATH" ]]; then

            if command cp $HOLLAEX_IMPORT_PATH $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi
        
        fi

    fi

    if [[ "$IS_IMPORT_SUCCESS" == true ]]; then 

        printf "\033[92mYour settings files has been imported into your HollaEx Kit!\033[39m\n"
        echo "If you are trying to run a brand-new exchange, proceed to run 'hollaex setup'."
        echo "If you are already running the exchange, and trying to apply reconfigured files, run 'hollaex restart'."

    else 

        printf "\033[91m\nFailed to import your files into HollaEx Kit.\033[39m\n"
        echo "Please confirm that you passed the correct path of your settings files (or directory), and try again."

        exit 1;
    
    fi

elif [[ "$1" == "login" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    function hollaex_login_form() {

        echo -e "\033[1mbitHolla Account Email:\033[0m "
        read email

        echo -e "\033[1mbitHolla Account Password:\033[0m "
        read -s password
        printf "\n"

        echo -e "\033[1mOTP Code\033[0m (Enter if you don't have OTP set for your account): "
        read otp

        BITHOLLA_ACCOUNT_TOKEN=$(curl -s -H "Content-Type: application/json" \
            --request POST \
            --data "{\"email\": \"${email}\", \"password\": \"${password}\", \"otp_code\": \"${otp}\", \"service\": \"cli\"}" \
            https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/login \
            | jq -r '.token')

        if [[ ! "$BITHOLLA_ACCOUNT_TOKEN" ]] || [[ "$BITHOLLA_ACCOUNT_TOKEN" == "null" ]]; then

            printf "\033[91mFailed to authenticate on bitHolla Server with your passed credentials.\033[39m\n"
            echo "Please try it again."
            exit 1;

        else 

            printf "\033[92mSuccessfully authenticated on bitHolla Server.\033[39m\n"
            # echo "Info: Your authentication will be only available for 24 hours."

            echo $BITHOLLA_ACCOUNT_TOKEN > $HOLLAEX_CLI_INIT_PATH/.token

            if [[ "$HOLLAEX_LOGIN_RENEW" ]]; then 

                exit 0;

            fi 

        fi

    }

    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        echo "Validating the existing access token..."
        BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

        BITHOLLA_USER_TOKEN_EXPIRY_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange)

        BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange \
            | jq '.')

        if [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" ]] || [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" == "200" ]]; then

            printf "\033[91mError: Your access token has been expired!\033[39m\n"
            printf "Please login again with your bitHolla account to issue a new access token.\n\n"
            hollaex_login_form;

        else

            echo -e "\033[92mYour existing access token is valid!\033[39m"
            echo "Info: If you want to revoke the existing token manually, remove '.token' file at your Kit."

        fi

    else 

        hollaex_login_form;

    fi

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange \
       | jq '.')
    
    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')
    
    # Exit with error if user doesn't have any exchange on the account.
    if [[ "$BITHOLLA_USER_EXCHANGE_COUNT" == "0" ]]; then

        printf "\n\033[91mError: You don't have any exchange on your account.\033[39m\n"
        echo "Please go to the bitHolla Dashboard (dash.bitholla.com), and do an exchange configuration first."
        
        exit 1;

    fi

    # Subtracting 1 from total count due to the array starts from 0, not from 1.
    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    printf "\n"

    function hollaex_login_select_exchange() {

        printf "Please pick the \033[1mexchange number\033[0m you want to bind.\n\n"

        for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        printf "Exchange number : \033[1m$((i+1))\033[0m\n";

        echo "Name:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name");
        echo "Activation Code:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code");
        printf "\n"

        EXCHANGE_NAME_TEMP=EXCHANGE_NAME_${i}
        EXCHANGE_ACTIVATION_CODE_TEMP=EXCHANGE_ACTIVATION_CODE_${i}

        export $(echo $EXCHANGE_NAME_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name";);
        export $(echo $EXCHANGE_ACTIVATION_CODE_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code";);

        done;

        printf "Input the exchange number: "
        read answer

        while true;
            do if [[ ! "${answer}" =~ ^[0-9]+$ ]]; then 
                printf "\033[91m\nError: The input always should be numberic.\033[39m\n"
                echo "Please pick the exchange number you want to bind."
                read answer
            else
                break;
            fi
        done

        answer=$((answer-1))
        
        printf "\n"
        SELECTED_EXCHANGE_NAME=EXCHANGE_NAME_${answer}
        SELECTED_EXCHANGE_ACTIVATION_CODE=EXCHANGE_ACTIVATION_CODE_${answer}

        if [[ ! "${!SELECTED_EXCHANGE_NAME}" ]] || [[ ! "${!SELECTED_EXCHANGE_ACTIVATION_CODE}" ]]; then

            printf "\033[91m\nError: Failed to read the data from the selected exchange.\033[39m\n"
            printf "Please make sure that you selected the correct number, and try again.\n\n"
            hollaex_login_select_exchange;

        fi
        
        echo -e "\033[1mSelected Exchange name: ${!SELECTED_EXCHANGE_NAME}\033[0m"
        echo -e "\033[1mSelected Activation code: ${!SELECTED_EXCHANGE_ACTIVATION_CODE}\033[0m"
        echo "Do you want to continue? (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

            hollaex_login_select_exchange;

        fi
    }

    hollaex_login_select_exchange;

    if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${!SELECTED_EXCHANGE_ACTIVATION_CODE}/" $SECRET_FILE_PATH; then

        rm $SECRET_FILE_PATH.bak

        printf "\n\033[92mSuccessfully bound the selected exchange to HollaEx Kit.\033[39m\n"

    else

        printf "\033[91mFailed to bind selected exchange to HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi

elif [[ "$1" == "logout" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;
    
    if [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Activation code.\033[39m\n"
        echo "'hollaex logout' works only after you successfully logged in."
        exit 1;
    
    fi

    printf "\nCurrent bound Exchange name: \033[92m$HOLLAEX_CONFIGMAP_API_NAME\033[39m\n\n"
    echo "This command will remove both Exchange name and Activation code from your local HollaEx Kit."
    echo "The rest of Exchagne configurations WILL NOT BE removed."
    echo "Are you sure you want to unbind this exchange from HollaEx Kit? (y/N)"
    read answer

    if [[ "$answer" = "${answer#[Yy]}" ]]; then
        echo "Exiting..."
        exit 0;
    fi

    # Removing the login token
    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        rm $HOLLAEX_CLI_INIT_PATH/.token
    
    fi

    if command sed -i.bak "s/HOLLAEX_CONFIGMAP_API_NAME=.*/HOLLAEX_CONFIGMAP_API_NAME=/" $CONFIGMAP_FILE_PATH; then

        rm $CONFIGMAP_FILE_PATH.bak

        if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=/" $SECRET_FILE_PATH; then

            rm $SECRET_FILE_PATH.bak

            printf "\n\033[92mSuccessfully removed the exchange data from HollaEx Kit.\033[39m\n"
        fi
    
    else

        printf "\033[91mFailed to remove exchange data from HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi

elif [[ "$1" == "pull" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Activation code.\033[39m\n"
        echo "'hollaex pull' works only after you successfully logged in."
        echo "Please run 'hollaex login' to sign in first."
        exit 1;
    
    fi

    if [[ "$RUN_WITH_VERIFY" == true ]]; then 

        printf "\nCurrent bound activation code: \033[92m$HOLLAEX_SECRET_ACTIVATION_CODE\033[39m\n\n"
        echo "This command will override the current Exchange settings at '/settings' folder of your HollaEx Kit."
        echo "Are you sure you want to pull the exchange settings from bitHolla Dashboard? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
    
    fi 

    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

    else 

        printf "\033[91mError: An access token has not been detected.\033[39m\n"
        printf "Please login with your bitHolla account to issue an access token.\n\n"
        hollaex login --renew

    fi

    BITHOLLA_USER_TOKEN_EXPIRY_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange)

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange \
       | jq '.')

    if [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" ]] || [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" == "200" ]]; then

        printf "\033[91mFailed to pull the exchange data from bitHolla.\033[39m\n\n"
        printf "\033[91mError: Your access token has been expired!\033[39m\n"
        printf "Please login again with your bitHolla account to issue a new access token.\n\n"
        hollaex login --renew

    else 

        printf "\n\033[92mSuccessfully authenticated on bitHolla Server.\033[39m\n"
        printf "Proceeding to pull data from bitHolla...\n"

    fi

    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code") == "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

            export BITHOLLA_USER_EXCHANGE_ORDER=$i
        
        fi

    done;

    if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].is_completed") == false ]]; then

        BITHOLLA_USER_EXCHANGE_UPDATED_DATE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].updated_at" | cut -f1 -d "T" | tr -d '-')
        BITHOLLA_DASH_1_3_RELEASE_DATE=20200219

        printf "\n\033[91mError: Your exchange is not fully configured at bitHolla Dashboard.\033[39m\n"
        printf "Please finalize the exchange setup at bitHolla Dashboard (https://dash.bitholla.com), and try agian.\n\n"

        if (($BITHOLLA_DASH_1_3_RELEASE_DATE > $BITHOLLA_USER_EXCHANGE_UPDATED_DATE)); then

            printf "\033[1mFor the HollaEx users who updated the exchange before Feb 19th, 2020.\033[0m\n"
            printf "You should \033[1mgo through the exchange setup once more\033[0m to update your exchange status.\n"
            printf "You don't need to update any vaules on the dashboard if it's not required.\n\n"

        fi

        exit 1;

    fi

    hollaex_pull_and_apply_exchange_data;

    apply_coins_config_to_settings_file;

    apply_pairs_config_to_settings_file;

    if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

        printf "\n\033[92mSuccessfully pulled and applied your exchange data to Hollaex Kit!\033[39m\n\n"

        if [[ ! "$RUN_WITH_VERIFY" ]]; then

            echo "You can now proceed to run 'hollaex setup' to initialize your brand-new exchange."
            printf "If you already have existing exchange, Please run 'hollaex restart' to apply new configurations.\n"
            
        fi

    else

        printf "\033[91mError: Failed to pull and apply data from bitHolla.\033[39m\n"
        echo "Please review the logs and try it again."
        exit 1;

    fi


elif [[ "$1" == "start" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --with_backends)
                WITH_BACKENDS=true
                echo "Creating backend components. Running backend components such as PostgreSQL or Redis together on this machine."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #Regenerate random secrets
    update_random_values_to_config;


    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then


        #     echo "Are you sure you want to start (scale up) $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        #Generating and updating settings

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        echo "Applying configmap on the namespace"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying secret on the namespace"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            helm_dynamic_trading_paris scaleup;

            helm_dynamic_trading_paris run;

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            echo "Applying Ingress rules..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            echo "All done!"
            echo "Containers successfully scaled up"

            hollaex_ascii_exchange_is_up;

            exit 0;

        else 

            echo "HollaEx CLI failed to detect existing exchange running on this Kubernetes."
            echo "Please review your settings files and targeted Kubernetes."

            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;
        
        LOCAL_COMMAND="up -d"

        #Quit if necessary flags are missing
        if [[ ! "$LOCAL_COMMAND" ]]; then

            echo "Some necessary flags are missing! Please check agian your command."
            print_usage;
            exit 1;

        fi

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     echo "Are you sure you want to start $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi  
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml $LOCAL_COMMAND; then

            hollaex_ascii_exchange_is_up;
        
        else 

            printf "\033[91mFailed to start exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "prod" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # for i in ${CONFIG_FILE_PATH[@]}; do
    #     source $i
    # done;
    
    source $SCRIPTPATH/tools_generator.sh
    # load_config_variables;

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        
        printf "\nPreparing the exchange for production deployment\n\n"

        echo -e "This command is going to apply \033[1mproduction domain\033[0m to your exchange."
        echo -e "Before you proceed make sure you have your own exchange domain. (Required)"
        echo -e "\033[1mAre you ready to proceed? (Y/n)\033[0m"

        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    function hollaex_prod_domain_questions() {

        # Web Domain
        echo "***************************************************************"
        echo "Exchange Web Domain"
        printf "\033[2m- Enter the full domain of your exchange website, without 'http' or 'https'.\033[22m\n"
        read answer
        
        while true;
            do if [[ "$answer" == *"http"* ]]; then
                printf "\nValue should be an URL without 'http' or 'https'.\n\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            elif [[ -z "$answer" ]]; then
                printf "\nThe value should not be empty!\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            else
                break;
            fi
        done

        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP//\//\\/}

        printf "\n"
        echo "${INPUT_HOLLAEX_CONFIGMAP_DOMAIN} ✔"
        printf "\n"

        #Automatically mark the API url as api.<MY_DOMAIN>
        export INPUT_HOLLAEX_CONFIGMAP_API_HOST="api.${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"

        printf "Since you selected the Exchange Web domain as: \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN,\033[0m\n"
        printf "Your Exchange Server \033[1mAPI domain\033[0m would be: \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[0m.\n"
        printf "Type \033[1m'Y'\033[0m to continute, or \033[1m'N'\033[0m to modify the Exchange Server API domain. (Y/n)\n"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
        
            # API Domain
            echo "***************************************************************"
            echo "Exchange Server API Domain"
            printf "\033[2m- Enter the full domain of your exchange API server, without 'http' or 'https'.\033[22m\n"
            read answer

            while true;
                do if [[ "$answer" == *"http"* ]]; then
                    printf "\nValue should be an URL without 'http' or 'https'.\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                elif [[ -z "$answer" ]]; then
                    printf "\nThe value should not be empty!\n\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                else
                    break;
                fi
            done

            export INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"

            printf "\n"
            echo "${INPUT_HOLLAEX_CONFIGMAP_API_HOST} ✔"
            printf "\n"

        fi 

        local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        printf "\nYour Exchange Web Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN\033[39m"
        printf "\nYour Exchange API Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[39m\n"
        echo "Type 'Y' to proceed (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
            hollaex_prod_domain_questions;

        else 

            echo "Updating user settings file based on the provided values..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done
        
        fi

    }

    # Asking for domains questions for production.
    hollaex_prod_domain_questions;

    #Checking the domains are reachable
    function hollaex_prod_check_domains_reachability() {
        
        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_DOMAIN > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange web URL ($INPUT_HOLLAEX_CONFIGMAP_DOMAIN).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=true

        else 

            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=false
        
        fi

        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange API URL ($INPUT_HOLLAEX_CONFIGMAP_API_HOST).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=true

        else

            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false
        
        fi

        if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

            # Announcing the domain configuration how-to.
            SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

            if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
                printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
                echo "You should check it by yourself."
                SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
            fi

            printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

            if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."
            fi

            if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."

            fi

            printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
            echo "Info: You could always quit the DNS checking loop with 'Crtl + C'."
            hollaex_prod_check_domains_reachability;

        fi
    }

    hollaex_prod_check_domains_reachability;

    # if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #     # Announcing the domain configuration how-to.
    #     SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

    #     if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
    #         printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
    #         echo "You should check it by yourself."
    #         SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
    #     fi

    #     printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
    #         printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
    #         printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
    #         read -p "Press enter once you configured the DNS."
    #     fi

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
    #         printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
    #         printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
    #         read -p "Press enter once you configured the DNS."

    #     fi

    #     printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
    #     hollaex_prod_check_domains_reachability;

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mWarning: Your domain URLs are still not reachable.\033[39m\n\n"
    #         printf "It could take \033[1mfew minutes ~ few hours to the DNS gets fully configured\033[0m and functioning.\n"
    #         printf "Checking the DNS status again...\n"
    #         hollaex_prod_check_domains_reachability;

    #     fi

    # fi
    
    printf "\n"
    echo "Do you want to issue SSL cert for your exchange? (Y/n)"
    echo "If you are going to use an external load balancer with SSL, Please type 'N'."
    
    read answer 

    printf "\n"

    if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
        echo "Skipping to issue SSL cert..."
        printf "\n\n\033[93mInfo: You could also issue SSL cert later by running 'hollaex toolbox --issue_ssl' command.\033[39m\n"

    else 

        if [[ "$USE_KUBERNETES" ]]; then

            echo "HollaEx CLI natively supports issuing SSL cert through 'cert-manager' and Let's encrypt."
            echo "Please make sure to install latest 'cert-manager' on your Kubernetes cluster."
            echo "Official document is available for installation. (cert-manager.io/docs/installation/kubernetes)"

            echo "The 'cert-manager' requires an issuer name to reach SSL ACME service."
            echo "Please provide your cert-manager issuer name."
            read answer

            echo "Updating the issuer name on user's settings file."
            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=.*/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=$answer/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

        elif [[ ! "$USE_KUBERNETES" ]]; then

            echo "HollaEx CLI natively supports issuing SSL cert through 'certbot' and Let's encrypt."
            echo "Running 'certbot' now..."
            printf "\n"
            while true;
                do if command hollaex toolbox --issue_ssl --skip; then

                    echo "Do you want to issue more SSL cert for different domain? (Y/n)"
                    read answer

                    if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                        echo "Skipping..."
                        break;

                    else 

                        hollaex toolbox --issue_ssl --skip;

                    fi
                
                else 

                    printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
                    exit 1;

                fi

            done;

            
        fi

        echo "Updating domains on settings files to use 'https' as a prefix..."

        INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS//\//\\/}

        INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS//\//\\/}

        for i in ${CONFIG_FILE_PATH[@]}; do

            # Update exchange name
            if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
            fi
            
        done

    fi

    hollaex_prod_complete;

    exit 0;

elif [[ "$1" == "stop" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
           --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    # Export hollaex-kit directory

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #check_empty_values_on_settings

    if [[ "$USE_KUBERNETES" ]]; then
        

         #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if ! command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Scaling down containers on the cluster..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        helm_dynamic_trading_paris scaledown;

        echo "Scaling down backend components..."

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_stopped;

        # exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop $HOLLAEX_CONFIGMAP_API_NAME running on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            hollaex_ascii_exchange_has_been_stopped;

        else 

            printf "\033[91mFailed to stop exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        #exit 0;

    fi

elif [[ "$1" == "restart" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #Regenerate random secrets
    update_random_values_to_config;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Removing ingress for web client on the namespace"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        echo "Applying latest configmap env on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying latest secret on the cluster"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Restarting all exchange containers on cluster"
        kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

        echo "Flushing Redis..."
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

        echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Applying ingress for web client on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        hollaex_ascii_exchange_is_up;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            printf "\033[91mHollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI.\033[39m\n"
            
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then

            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        # echo "Restarting containers to apply new changes..."
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

        echo "Flushing Redis..."
        IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
        docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js
        
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --remove-orphans; then
                
                hollaex_ascii_exchange_is_up;

            else 

                printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
                exit 1;
            fi

        else 

            printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "build" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target hollaex release version : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    build_user_hollaex_core;


elif [[ "$1" == "upgrade" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --user-image-registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_REGISTRY_OVERRIDE=$1
                echo "User HollaEx Core image registry and version : $ENVIRONMENT_USER_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=${1:-$HOLLAEX_CORE_MAXIMUM_COMPATIBLE}
                echo "Target HollaEx Core release version : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
             --no_image_build)
                NO_IMAGE_BUILD=true
                echo "Skipping the new image build."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    echo "Checking the version compatibility between the latest HollaEx CLI and your local Kit..."
    if command curl -s -f https://raw.githubusercontent.com/bitholla/hollaex-cli/master/version_range > $SCRIPTPATH/.master_version_range; then 

        source .master_version_range
        rm .master_version_range

    else 

        printf "\n\033[91mError: Failed to read latest version compatibility range from the server.\n\033[39m"
        echo "Please check your internet connectivity and try it again."
        
        exit 1;

    fi

    # Check Kit version compatibility range.
    check_version_compatibility_range;

    # Update HollaEx CLI to latest if there is newer release available.
    update_hollaex_cli_to_latest;

    # Override target docker image version if user passed it manually with flag / version range available at each CLI releases.     
    override_docker_image_version;
    export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
        

    # Override target docker registry if user passed it manually with flag.
    if [[ "$ENVIRONMENT_USER_REGISTRY_OVERRIDE" ]]; then
        
        override_user_docker_registry;
        
    fi

    if [[ ! "$NO_IMAGE_BUILD" ]]; then

        # Building new HollaEx Core image based on passed (or specified) version.
        build_user_hollaex_core;
    
    fi

    #Regenerate random secrets
    update_random_values_to_config;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME by using $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY:$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION with $ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS api containers on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi
        
        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Applying latest configmap env on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying latest secret on the cluster"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then
        
            echo "Applying web client configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-web-configmap.yaml

        fi

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Upgrading $HOLLAEX_CONFIGMAP_API_NAME Pods on Kubernetes."
        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="api" --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" --set stable.replicaCount="2" --set autoScaling.hpa.enable="true" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="stream" --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="plugins-controller" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server
        
        helm_dynamic_trading_paris run;

        # Running database job for Kubernetes
        kubernetes_database_init upgrade;

        echo "Flushing Redis..."
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

        echo "Restarting all containers to apply latest database changes..."
        kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

        echo "Waiting for the containers get fully ready..."
        sleep 15;

        echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Applying ingress for web client on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi


        hollaex_ascii_exchange_has_been_upgraded;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Override target docker image version If user passed it manually with flag.
        if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
            
            override_docker_image_version;
            ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
            
        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi
        
        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then

            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        echo "Restarting containers to apply new changes..."
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --build; then

            RUN_WITH_VERIFY=false
            local_database_init upgrade;

            echo "Flushing Redis..."
            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart; then

                hollaex_ascii_exchange_has_been_upgraded;
            
            else 

                printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
                exit 1;

            fi

        else

            printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

        exit 0;

    fi

elif [[ "$1" == "terminate" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

         # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Removing helm packages on the cluster."
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-api
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-stream
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller

        helm_dynamic_trading_paris terminate;

        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-redis 
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-db
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-influxdb

        #Remove web server together if it exists on same namespace.
        if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then
            
            helm del --purge $ENVIRONMENT_EXCHANGE_NAME-web

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME namespace."
        kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated. If there's an issue, please review the logs and try it again."

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down --remove-orphans -v

        # Remove web server together if it exists.
        if [[ -f "$TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml" ]] ; then

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down 
        fi

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        echo "To setup the exchange again from a scratch, please run 'hollaex setup'"
        printf "\nBye!\n\n"

        exit 0;

    fi

elif [[ "$1" == "web" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "Setting target to Kubernetes..."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --setup)
                WEB_CLIENT_SETUP=true
                shift; continue
                ;;
            --start)
                WEB_CLIENT_START=true
                shift; continue
                ;;
            --stop)
                WEB_CLIENT_STOP=true
                shift; continue
                ;;
            --restart)
                WEB_CLIENT_RESTART=true
                shift; continue
                ;;
            --build)
                WEB_CLIENT_REBUILD=true
                shift; continue
                ;;
            --terminate)
                WEB_CLIENT_TERMINATE=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Setting web operation enabled command to true.
    ENVIRONMENT_WEB_ENABLE=true

    # hollaex web --setup
    if [[ "$WEB_CLIENT_SETUP" ]]; then

        build_user_hollaex_web;

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to setup the web server on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi
            
            # Web server installation status checking.
            if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: You already installed the web server on your Kuberentes cluster!\033[39m\n"
                echo "To start it, Please run 'hollaex web --start --kube' command instead."

                exit 1;
            
            fi

            #Creating kubernetes_config directory for generating config for Kubernetes.
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            
            # Create docker registry secret on Kubernetes.
            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

            echo "Running the web server on Kubernetes..."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="1" \
                        --set autoScaling.hpa.enable="false" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then


                echo "Scaling down the web server after the initialization..."
                hollaex web --stop --kube --skip

                hollaex_ascii_web_server_has_been_setup;
            
            else 

                printf "\n\033[91mFailed to setup the web server on the Kubernetes!\033[39m\n"
                echo "Please review the logs and try again."

                helm del --purge $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null;

                exit 1;

            fi

            exit 0;
        
        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to setup the web server on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            #Generating nginx conf.d folder
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Generating web Nginx upstream file"
            generate_nginx_upstream_for_web

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex web --stop --skip

                hollaex_ascii_web_server_has_been_setup;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review the logs and try again."
                exit 1;
            
            fi

            exit 0;

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_START" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start (scale up) the web server on this cluster? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi
            
            # Web server installation status checking.
            if ! command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
                echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

                exit 1;
            
           fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml


            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            echo "Starting (Scaling up) the web server on Kubernetes..."
            if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 ; then

                hollaex_ascii_web_server_is_up;
            
            else 

                printf "\033[91mFailed to start the web on your Kubernetes cluster!033[39m\n"
                echo "Please review the logs and try again."

                exit 1;

            fi
        

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if ! command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

                echo "Error: Can't detect built web docker image on this machine!"
                echo "If this is your first time launching the web server, please run 'hollaex web --setup' instead."
                echo "You can also build the image manually by using 'hollaex web --build' command."

                exit 1;
              
            fi

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start the web client on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            if ! command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: Failed to detect stopped web server on this machine.\033[39m\n"
                echo "If you haven't setup the web server yet, Please run 'hollaex web --setup' first."

                exit 1;

            fi

            #Generating nginx conf.d folder
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client start; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_STOP" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) the web server on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Web server installation status checking.
        echo "Checking the web installation status on your Kubernetes..."
        if ! command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

            printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
            echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

            exit 1;
        
        fi

        echo "Removing web ingress rules from the Kubernetes"
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        echo "Stopping (Scaling down) the web server..."
        if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME; then

            printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
            echo "To bring it up, Please run 'hollaex web --start --kube' command".
        
        else 

            printf "\033[91m\nError: Failed to stop the web server on the Kubernetes.\033[39m\n"
            echo "Please review the logs and try again."

            exit 1;
        
        fi
    
        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to stop the web client on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
                echo "To bring it up, Please run 'hollaex web --start' command".

            else 

                printf "\n\033[91mError: Failed to stop the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

        fi

        exit 0;
        
    fi

    if [[ "$WEB_CLIENT_RESTART" ]]; then

        if command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

            printf "\nPre-built image for web server has been detected on your system.\n"
            echo "You should build the image again if you made code changes for web."
            echo "Plase input 'Y' to skip the build, 'N' to build the image again."
            echo "Do you want to proceed with the pre-built image? (Y/n)"
            read answer 

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                build_user_hollaex_web;
            
            else 

                echo "Proceeding..."
            
            fi
        
        else 

            echo "Building the web server image..."
            build_user_hollaex_web;

        fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Restarting the $HOLLAEX_CONFIGMAP_API_NAME web server."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --recreate-pods \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="1" \
                        --set autoScaling.hpa.enable="false" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then

                # Scaling up the web in case of it gets already scaled down.
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                echo -e "\n\033[92mSuccessfully restarted the web server on the Kubernetes!\033[39m\n"

                hollaex_ascii_web_server_is_up;
               
            else 

                printf "\033[91mFailed to restart the web server.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                echo "Generating web Nginx configuration file"
                generate_hollaex_web_local_nginx_conf

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then
                
                docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_REBUILD" ]];  then
    
        build_user_hollaex_web;

        exit 0;

    fi

    if [[ "$WEB_CLIENT_TERMINATE" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web server on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Removing web ingress rule on the cluster"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Removing the web server..."
            if command helm del --purge $ENVIRONMENT_EXCHANGE_NAME-web; then

                printf "\n\033[92mWeb server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup --kube' if you want to set it up again."
            
            else 

                printf "\033[91mFailed to terminate the web server from the Kubernetes.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

            exit 0;
                

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web client on this machine? (y/N)"
                echo "This can't be undo."

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down --remove-orphans; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mThe web server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup' to set it up again."

            else 

                printf "\033[91mHollaEx CLI failed to terminate the web server. Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

            exit 0;

        fi
    fi

elif [[ "$1" == "toolbox" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --dev)
                IS_DEVELOP=true
                echo "HollaEx CLI is configured as dev mode for development purpose."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKENDS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will upgrade your backends (PostgreSQL, Redis, InfluxDB) based on your settings files value."
                shift; continue
                ;;
            --backup)
                BACKUP_POSTGRESQL=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run PostgreSQL database dump on your initialized exchange folder."
                shift; continue
                ;;
            --flush_redis)
                FLUSH_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run full flush of Redis stored data. This could be helpful in certain situation If the exchange doesnt work properly."
                shift; continue
                ;;
            --upgrade_api_only)
                UPGRADE_API_ONLY=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will rolling-upgrade API containers only for Kubernetes."
                shift; continue
                ;;
            # Version flag for --upgrade_api_only (rolling upgrade) for Kubernetes deployment.
             --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target HollaEx release version for API rolling upgrade : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --add_coin)
                ADD_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new coin on your existing exchange."
                shift; continue
                ;;
            --add_trading_pair)
                ADD_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new trading pair on your existing exchange."
                shift; continue
                ;;
            --remove_coin)
                REMOVE_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove coin on your existing exchange."
                shift; continue
                ;;
            --remove_trading_pair)
                REMOVE_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove trading pair on your existing exchange."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            # --reconfigure_basic_settings)
            #     RECONFIGURE_BASIC_SETTINGS=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reconfigure your exchange's basic settings."
            #     shift; continue
            #     ;;
            # --reactivate_exchange)
            #     REACTIVATE_EXCHANGE=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reactivate your exchange with new activate information."
            #     shift; continue
            #     ;;
            --issue_ssl)
                ISSUE_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to issue SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
            --renew_ssl)
                RENEW_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to renew SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
             --update_registry_secret)
                UPDATE_REGISTRY_SECRET=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your docker image registry secret for Kubernetes."
                shift; continue
                ;;
            --set_activation_code)
                SET_ACTIVATION_CODE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your activation code for the exchange."
                shift; continue
                ;;
            --set_config)
                SET_CONFIG=true
                TOOLBOX_ENABLE=true
                echo "Override database-stored cosntants with local configmap-stored values."
                shift; continue
                ;;
             --connect_database)
                CONNECT_DATABASE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via postgresql-client."
                shift; continue
                ;;
             --connect_redis)
                CONNECT_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via redis-client."
                shift; continue
                ;;
             --connect_influxdb)
                CONNECT_INFLUXDB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via influx-client."
                shift; continue
                ;;
            --install_cli)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                INSTALL_CLI_ENABLE=true
                INSTALL_CLI_TARGET=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    # PATH overriding for develop    
    if [[ "$IS_DEVELOP" ]]; then

        if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex

        elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$(pwd)/.hollaex
            HOLLAEX_CODEBASE_PATH=$(pwd)

        fi

    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    if [[ ! "$TOOLBOX_ENABLE" ]]; then
    
        print_usage;
        echo "No features are enabled for toolbox. Please recheck the command."
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # --version flag for --upgrade_api_only
    # Override target docker image version if user passed it manually with flag.
    if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
        
        override_docker_image_version;
        export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
        
    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

    fi

    # Features
    if [[ "$UPGRADE_BACKENDS" ]]; then 

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        echo "All workload containers will be restarted once the upgrade process is done."
    
        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Deleting Ingress rules for the exchange..."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            
            if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

                echo "Upgrading PostgreSQL DB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql

                helm upgrade $ENVIRONMENT_EXCHANGE_NAME-db --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set imageRegistry="${ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY}" --set dockerTag="${ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION}" --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" ]]; then

                echo "Upgrading Redis"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

                helm upgrade $ENVIRONMENT_EXCHANGE_NAME-redis --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" ]]; then
                
                echo "Upgrading InfluxDB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret"  -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)

            fi

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            sleep 10;

            echo "Applying Ingress rules for the exchange..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "All workload containers will be restarted once the upgrade process is done."

            echo "Regenerating docker-compose file..."
            generate_local_docker_compose $ENVIRONMENT_EXCHANGE_RUN_MODE

            echo "Restarting containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

            exit 0;

        fi

    elif [[ "$BACKUP_POSTGRESQL" ]]; then

        # Check pg_dump is available on your local
        if command pg_dumpall --version > /dev/null 2>&1; then

            echo "pg_dump detected on your machine!"
            pg_dumpall --version

        else 

            echo "HollaEx CLI failed to detect pg_dump on your machine"
            echo "Please make sure that you already installed pg_dump"

            exit 1;

        fi 

        if [[ ! -d $HOLLAEX_CLI_INIT_PATH/backups ]]; then

            echo "Creating '/backups' folder on HollaEx Kit directory"
            mkdir $HOLLAEX_CLI_INIT_PATH/backups

        fi

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Running pg_dumpall..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will backup your local PostgreSQL DB."

            echo "Running pg_dumpall..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            exit 0;

        fi
        
    elif [[ "$FLUSH_REDIS" ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run flush Redis data on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to to run flush Redis data on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Shutting down Nginx to block exchange external access"
            docker stop $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ")

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            
            echo "Flushing Redis..."
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            sleep 10;

            exit 0;
        fi
        
    elif [[ "$UPGRADE_API_ONLY" ]]; then

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to do rolling upgrade for $HOLLAEX_CONFIGMAP_API_NAME api pods to v$ENVIRONMENT_DOCKER_IMAGE_VERSION on this cluster? (y/N)"
                echo "Configmap values would be updated either while on the rolling upgrade"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

                echo "Generating Kubernetes Configmap"
                generate_kubernetes_configmap;

            fi

             if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

                echo "Generating Kubernetes Secret"
                generate_kubernetes_secret;

            fi

            echo "Applying latest configmap env on the cluster."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying latest secret on the cluster"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            echo "Upgrading $HOLLAEX_CONFIGMAP_API_NAME API pods only on Kubernetes."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --reuse-values \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

            echo "Rolling upgrade process has been finished."
            echo "It would take few minutes to Kubernetes replace api pods to new version completely. Please check the status constantly."
            
            exit 0;
            
        
        elif [[ ! "$USE_KUBERNETES" ]] ; then

            echo "HollaEx CLI only supports rolling-upgrade for api contianers on Kubernets environment."
            echo "Please use --kube flag to point Kubernetes."

            exit 1;

        fi


    elif [[ "$ADD_COIN" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom currencies on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$HOLLAEX_CONFIGMAP_CURRENCIES"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export COIN_SYMBOL=$j
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_COIN_$(echo $j | tr a-z A-Z)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mCoin configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_coin_exec;
                    
                    else 

                        printf "\033[91mError: Coin configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."

                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "CURRENCIES=${HOLLAEX_CONFIGMAP_CURRENCIES}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        else 

            printf "\033[93mWarning: Adding new coin requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_coin_input;

            add_coin_exec;
        
        fi
        
    elif [[ "$REMOVE_COIN" ]]; then

        printf "\033[93mWarning: Removing new coin requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"
        
        remove_coin_input;

        remove_coin_exec;
    
    elif [[ "$ADD_TRADING_PAIR" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom trading pairs on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$HOLLAEX_CONFIGMAP_PAIRS"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export PAIR_NAME=$j
                    export PAIR_BASE=$(echo $j | cut -f1 -d "-")
                    export PAIR_2=$(echo $j | cut -f2 -d "-")
                    export PAIR_PREFIX=$(echo $PAIR_BASE | tr a-z A-Z)_$(echo $PAIR_2 | tr a-z A-Z)
     
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_PAIR_$(echo $PAIR_PREFIX)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mTrading pair configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_pair_exec;
                    
                    else 

                        printf "\033[91mError: Trading pair configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."
                    
                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "PAIRS=${HOLLAEX_CONFIGMAP_PAIRS}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        else 

            printf "\033[93mWarning: Adding new pair requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_pair_input;

            add_pair_exec;
        
        fi

    elif [[ "$REMOVE_TRADING_PAIR" ]]; then

        printf "\033[93mWarning: Removing new pair requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"
        
        remove_pair_input;

        remove_pair_exec;
    
    # elif [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

    #     # Ask for basic necessary settings
    #     launch_basic_settings_input;

    #     echo "Make sure to check your settings files been successfully updated by following your provided values."
    #     echo "Once it's all good, then you can proceed to actually update your exchange by using 'hollaex upgrade' command."
    #     echo "If you also updated activation code for the exchange, make sure to run 'hollaex toolbox --reactivate_exchange' command after 'hollaex upgrade'."

    # elif [[ "$REACTIVATE_EXCHANGE" ]]; then

    #     reactivate_exchange;
    

    elif [[ "$ISSUE_SSL_CERT" ]]; then
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to issue SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi
        fi

        echo "Issuing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot --nginx; then
            
            echo "SSL cert has been successfully set."
            echo "All the Let's encrypt related files can be found at ./templates/local/letsencrypt."

            echo "Updating domanin configurations to use HTTPS at user settings file..."

            UPDATED_HOLLAEX_CONFIGMAP_API_HOST=${HOLLAEX_CONFIGMAP_API_HOST//http:/https:}
            UPDATED_HOLLAEX_CONFIGMAP_DOMAIN=${HOLLAEX_CONFIGMAP_DOMAIN//http:/https:}

            ESCAPED_HOLLAEX_CONFIGMAP_API_HOST=${UPDATED_HOLLAEX_CONFIGMAP_API_HOST//\//\\/}
            ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN=${UPDATED_HOLLAEX_CONFIGMAP_DOMAIN//\//\\/}

            for i in ${CONFIG_FILE_PATH[@]}; do
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i

                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$ESCAPED_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
            done

            if command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then

                printf "\n\033[93mWarning: You should rebuild and restart your web server to apply SSL configuraion on the web.\033[39m\n\n"
                echo "The web server would malfunction if the server doesn't get rebuild"
                echo "Please run 'hollaex web --restart' to rebuild the image and apply."
                printf "\n"
                exit 0;

            fi

            printf "\n\nNote: The SSL certificate issued by Let's Encrypt requires a \033[1mrenewal in every 3 months.\033[0m\n"
            printf "Please make sure to run '\033[1mhollaex toolbox --renew_ssl\033[0m' to renew your SSL certificate before it gets expired.\n"
            printf "\n\nIt is recommended to \033[1msetup a Cronjob\033[0m to automate the renewal process."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
 
        
    
    elif [[ "$RENEW_SSL_CERT" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to renew SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Renewing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot renew; then
        
            echo "SSL cert has been successfully renewed."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
      

    elif [[ "$UPDATE_REGISTRY_SECRET" ]]; then

        if [[ ! "$USE_KUBERNETES" ]]; then 

            echo "Warning: Docker registry secret update is only available for Kubernetes."
            echo "Please use 'hollaex toolbox --update_registry_secret --kube' command instead."
            exit 1;

        fi

        check_kubernetes_dependencies;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        echo "Are you sure that you want to update your existing Docker registry secret at this Kubernets cluster? (y/N)"
        read answer 

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

        echo "Removing the current Docker registry secret at $ENVIRONMENT_EXCHANGE_NAME namespace."
        kubectl delete secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME

         if [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL" ]]; then

            echo "Docker registry credentials are detected at your configmap file."

            echo "*********************************************"
            echo "Docker Registry Host: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST"
            echo "Docker Registry Email: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL"
            echo "Docker Registery Username: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME"
            echo "Docker Registry Password: $(echo ${ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD//?/◼︎}$(echo $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD | grep -o '....$'))"
            echo "*********************************************"
            echo "You can either proceed with this values, or set it again manually by yourself."
            echo "Do you want to proceed with this values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                echo "Proceeding to a from to re-fill up the credentials."
                MANUAL_DOCKER_REGISTRY_SECRET_UPDATE=true

            fi
        
        fi

        create_kubernetes_docker_registry_secret;
    
    elif [[ "$SET_ACTIVATION_CODE" ]]; then
        
        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;
        
            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            echo "Are you sure that you want to update your activation code for the exchange on this Kubernets cluster? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart --kube' to fully apply it."


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            echo "Are you sure that you want to update your activation code for the exchange on this machine? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart' to fully apply it."

        fi

    elif [[ "$SET_CONFIG" ]]; then

        function toolbox_set_config_confirm_message() {

            echo "Warning: This command is not recommended for most of users in most of use cases."
            echo "This command would completely override your database to update values with local settings."
            echo "Are you sure you want to update database-stored constatns with your local configmap values? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_config_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            set_config_exec;
            

        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_config_confirm_message;

            set_config_exec;

        fi


    elif [[ "$CONNECT_DATABASE" ]]; then

        if ! command psql --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect postgresql-client at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for database connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &
                sleep 5;
                
                echo "Opening local proxy on 5432 port of your machine..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                echo "Opening postgresql-client shell..."
                psql 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect PostgreSQL database at your Kubernetes which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."

                echo "Opening postgresql-client shell..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                psql 

                exit 0;

            else

                echo "Failed to detect PostgreSQL database at your machine which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_REDIS" ]]; then

        if ! command rdcli --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect redis-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for Redis connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-redis" -o name | sed 's/pod\///' | head -n 1) 6379:6379 &
                sleep 5;
                
                echo "Opening local proxy on 6379 port of your machine..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                echo "Opening redis-client shell..."
                redis-cli 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect Redis at your Kubernetes which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."

                echo "Opening redis-cli shell..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                redis-cli 

                exit 0;

            else

                echo "Failed to detect Redis at your machine which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_INFLUXDB" ]]; then

        if ! command influx --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect influx-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the InfluxDB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for InfluxDB connection..."
                
                echo "Opening local proxy on 8086 port of your machine..."
                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-influxdb" -o name | sed 's/pod\///' | head -n 1) 8086:8086 &
                sleep 5;

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect InfluxDB at your Kubernetes which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the influx-cli created by HollaEx CLI."

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                exit 0;

            else

                echo "Failed to detect InfluxDB at your machine which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi
    
    elif [[ "$INSTALL_CLI_ENABLE" ]]; then

        if [[ ! "$INSTALL_CLI_TARGET" ]]; then

            echo "Error: You must specify version of the CLI to downgrade."
            echo "eg. 'hollaex toolbox --install_cli 1.8.5'."

            exit 1;

        fi

        echo "Are you sure you want to install HollaEx CLI v$INSTALL_CLI_TARGET? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
 
        bash $SCRIPTPATH/install.sh $INSTALL_CLI_TARGET
        
    fi


elif [[ "$1" == "status" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        kubectl get deployment --namespace $ENVIRONMENT_EXCHANGE_NAME

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect HollaEx on this machine. Please try it again.\033[39m\n"

        else 

            docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME

        fi

    fi

    printf "\nCalling the exchange health page ($HOLLAEX_CONFIGMAP_API_HOST/v1/health) ...\n"

    if command curl $HOLLAEX_CONFIGMAP_API_HOST/v1/health; then 

        printf "\n\033[92mSuccessfully reached to the exchange health page.\033[39m\n"

    else 

        printf "\033[91m\nExchange health page is not responding. Please check the exchange is up.\033[39m\n"

    fi

    exit 0;

elif [[ "$1" == "logs" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET=$1
                echo "Displaying Logs from $1..."
                shift; continue
                ;;
            # --lines and --line does same thing.
            --lines)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
            --line)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
           --export)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                echo "Exporting the result as a file."
                HOLLAEX_LOGS_EXPORT=true
                HOLLAEX_LOGS_EXPORT_PATH=$1
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    function hollaex_log_target_whitelist() {

        local whitelist=("api" "stream" "engine" "db" "redis" "influxdb" "plugins-controller")

        if ! command printf '%s\n' ${whitelist[@]} | grep $HOLLAEX_LOGS_TARGET > /dev/null; then
        
            printf "\033[91mError: Invalid target $HOLLAEX_LOGS_TARGET.\033[39m\n"
            echo "Command 'hollaex logs' only supports '${whitelist[@]}' as log target."
            echo "Pleases try it again."

            exit 1;

        fi
    }
    
    if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

        hollaex_log_target_whitelist;
    
    fi

    if [[ -d "$HOLLAEX_LOGS_EXPORT_PATH" ]]; then

        export HOLLAEX_LOGS_EXPORT_PATH="${HOLLAEX_LOGS_EXPORT_PATH}/hollaex-logs-$(date +%s).log"

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        function show_kubernetes_logs_simple() {

            hollaex version

            # Printing general system information
            echo "Client System OS Type: $OSTYPE"
            echo "Client System Shell Type: $SHELL"
            echo "Client System Shell Version: $(${SHELL} --version)"

            printf "\nKubernetes Version: $(kubectl version)\n\n"
            echo "Helm Version: $(helm version)"

            printf "\n#########################################################################\n"

            if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-*-$HOLLAEX_LOGS_TARGET | cut -f1 -d " ")

            else 
                
                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | cut -f1 -d " ")
            
            fi

            for i in ${POD_ID[@]}; do

                printf "\nPod : $i\n"

                    if [[ $(kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail 10) ]]; then

                            kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for Pod : $i."

                    fi

                printf "\n"

            done;
        
        }

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            show_kubernetes_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

        else 

            show_kubernetes_logs_simple
        
        fi


        printf "\n"
        echo "Displayed (Saved) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from pod(s)."

        if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then
            
            echo "To see logs from specific pod(s), Please run 'hollaex logs --kube --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
            echo "For example, 'hollaex logs --kube --target api --lines 20'."
        
        fi

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
            exit 0;

        fi

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect $ENVIRONMENT_EXCHANGE_NAME on this machine. Please try it again.\033[39m\n"

        else 

            function show_docker_logs_simple() {

                hollaex version

                # Printing general system information
                echo "System OS Type: $OSTYPE"
                echo "System Shell Type: $SHELL"
                echo "System Shell Version: $(${SHELL} --version)"

                printf "\n#########################################################################\n"

                if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-.*-$HOLLAEX_LOGS_TARGET)
                    echo $CONTAINER_ID

                else 
                
                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME)

                fi

                for i in ${CONTAINER_ID[@]}; do

                    printf "\nContainer : $i\n"

                    if [[ $(docker logs $i --tail 10) ]]; then

                            docker logs $i --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for container : $i."

                    fi

                    printf "\n"

                done;
            
            }

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                show_docker_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

            else 

                show_docker_logs_simple
            
            fi

            printf "\n"
            echo "Displayed (Exported) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from container(s)."

            if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then

                echo "To see logs from specific container(s), Please run 'hollaex logs --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
                echo "For example, 'hollaex logs --target api --lines 20'."
            
            fi

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
                exit 0;

            fi

        fi

    fi

    exit 0;
 

elif [[ "$1" == "version" ]]; then
     
    /bin/cat << EOF

1ttffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffttt.
.@@@000000000000000000000000000000000000000000000000000000000000000000@@@,
.0@G                                                                  L@8,
.8@G     fLL:  ;LLt         ;00L:00C         ;LfLCCCC;                C@@,
.8@G    .@@@;  i@@8  :1fti, i@@G;@@0 ,ittti, t@@0ttfL1ttt..ttt,       C@@,
.8@G    .8@@0GG0@@G:0@@LG@@f;@@C;@@0.L00L8@@;1@@0LL.  t@@CC@@1        C@@,
.8@G    .8@@LttC@@GC@@t  8@@f@@C;@@G:LGCtG@@1i@@Gtt    1@@@8:         C@8,
.8@G    .@@@;  i@@0i@@81L@@Ci@@G;@@0f@@G10@@t1@@8ffLL1i8@C0@8;.1t;    C@@,
.8@G     tff,  :fft ,1LCCf; ,ff1,fft.1LCL1ff;:fffLLLf;fff ,fLf,;i:    ;ii.
.0@G
.@@@888888888888888888888888888888888888888888888888888888888888888888880.
1ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt.

HollaEx CLI : v$(cat $SCRIPTPATH/version), Made with <3 by bitHolla Inc.

EOF

else

    printf "\nInvalid Command. Please try it again.\n"
    print_usage;

    exit 1;

fi

exit 0;


